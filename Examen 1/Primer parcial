{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Estudio de la Cinem√°tica y Din√°mica de un robot SCARA con tres grados de libertad\n",
    "\n",
    "**Nombre:** Rodriguez Torres Angel Adrian\n",
    "**Materia:** Robotica\n",
    "**Grupo:** 1\n",
    "**Profesor:** M.I. Erik Pe√±a Medina"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Resumen\n",
    "\n",
    "Este trabajo estudia el funcionamiento de un robot SCARA con tres eslabones y tres articulaciones rotacionales, uno de los cuales est√° fijo al sistema de referencia. El objetivo es comprender c√≥mo se relacionan la posici√≥n, la orientaci√≥n y los movimientos de cada articulaci√≥n con la tarea final que el robot debe realizar. Para ello, primero se desarrolla el modelo cinem√°tico, que permite describir la pose, las velocidades y la aceleraci√≥n del robot desde su base hasta el efector final.\n",
    "\n",
    "M√°s adelante, se formula el modelo din√°mico de esta configuraci√≥n empleando el m√©todo de Euler-Lagrange, tanto en su forma directa como inversa, lo que facilita analizar el comportamiento del sistema desde dos enfoques complementarios. Con esta integraci√≥n de los modelos cinem√°ticos y din√°micos se busca no solo describir los movimientos, sino tambi√©n entender c√≥mo la interacci√≥n entre las juntas y los eslabones condiciona la precisi√≥n, la eficiencia y la respuesta del robot en la ejecuci√≥n de sus tareas."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Introducci√≥n:\n",
    "\n",
    "La rob√≥tica moderna depende fundamentalmente de la capacidad para predecir y controlar con precisi√≥n el comportamiento de los manipuladores. Para lograr esto, es indispensable desarrollar un \"gemelo digital\", un conjunto de modelos matem√°ticos que describan fielmente la f√≠sica del robot. El presente reporte tiene como objetivo principal el desarrollo y la documentaci√≥n de los modelos cinem√°tico y din√°mico de un robot manipulador tipo SCARA de tres grados de libertad. El an√°lisis abarca desde la descripci√≥n de la postura y el movimiento del robot hasta las fuerzas necesarias para generarlo.\n",
    "\n",
    "Para el modelo cinem√°tico, se emplea la convenci√≥n de Denavit-Hartenberg y el uso de matrices de transformaci√≥n homog√©nea para la cinem√°tica directa, as√≠ como el an√°lisis Jacobiano para el estudio de las velocidades. Para el modelo din√°mico, se utiliza la formulaci√≥n de Euler-Lagrange, un m√©todo robusto basado en la energ√≠a del sistema que permite determinar los torques requeridos en cada articulaci√≥n.\n",
    "\n",
    "El documento se encuentra estructurado de la siguiente manera: las secciones 2, 3 y 4 desarrollan progresivamente el modelo cinem√°tico de la postura, velocidades y aceleraciones. La secci√≥n 5 detalla el modelo din√°mico. Finalmente, en la secci√≥n 6 se presentan las conclusiones del trabajo realizado."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Definici√≥n de funciones"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%Deficici√≥n de la funci√≥n de manera simbolica\n",
    "%syms Tij(x_i_j,y_i_j,z_i_j,gi_j,bi_j,ai_j)\n",
    "\n",
    "\n",
    "%Definici√≥n de la transformaci√≥n hom√≥genea general\n",
    "%Tij(x_i_j,y_i_j,z_i_j,gi_j,bi_j,ai_j) = [cos(ai_j)*cos(bi_j) cos(ai_j)*sin(bi_j)*sin(gi_j)-sin(ai_j)*cos(gi_j) sin(ai_j)*sin(gi_j)+cos(ai_j)*sin(bi_j)*cos(gi_j) x_i_j; sin(ai_j)*cos(bi_j) cos(ai_j)*cos(gi_j)+sin(ai_j)*sin(bi_j)*sin(gi_j) sin(ai_j)*sin(bi_j)*cos(gi_j)-cos(ai_j)*sin(gi_j) y_i_j; -sin(bi_j) cos(bi_j)*sin(gi_j) cos(bi_j)*cos(gi_j) z_i_j; 0 0 0 1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelado del robot Scara"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Planteamiento del modelo cinem√°tico de la posici√≥n\n",
    "\n",
    "El modelo cinem√°tico directo nos permite determinar la posici√≥n y orientaci√≥n del efector final del robot a partir de los valores conocidos de sus √°ngulos articulares. Para lograr esto, se modela cada eslab√≥n y articulaci√≥n como un sistema de coordenadas independiente. La relaci√≥n entre estos sistemas se establece mediante matrices de transformaci√≥n homog√©nea (T), las cuales representan la traslaci√≥n y rotaci√≥n entre un sistema y el siguiente.\n",
    "\n",
    "La matriz de transformaci√≥n total, que describe la ubicaci√≥n del efector final con respecto a la base, se obtiene multiplicando secuencialmente las matrices de cada eslab√≥n. A continuaci√≥n, se presenta el diagrama del robot analizado y el desarrollo del c√≥digo para obtener este modelo.\n",
    "\n",
    "Como este movimiento ocurre dentro de un plano, por ahora no consideramos la posici√≥n sobre el eje Z. Nuestro punto de referencia es el eje X, que nos permite observar la rotaci√≥n que realiza cada eslab√≥n alrededor del eje Z. El eje X se orienta de forma paralela a la longitud del eslab√≥n, lo que facilita describir los cambios en su orientaci√≥n. Como se mencion√≥ anteriormente, se emple√≥ el modelo de Denavit-Hartenberg. Esta matriz contiene la matriz de orientaci√≥n, el vector de posicion y la escala del punto que se analiza.\n",
    "\n",
    "El modelo cinem√°tico directo nos permite determinar la posici√≥n y orientaci√≥n del efector final del robot a partir de los valores conocidos de sus √°ngulos articulares. Para lograr esto, se modela cada eslab√≥n y articulaci√≥n como un sistema de coordenadas independiente. Un principio fundamental en este an√°lisis, especialmente para robots con juntas rotacionales como el SCARA, es la selecci√≥n de un sistema de referencia que simplifique el problema. Al analizar el movimiento desde un plano perpendicular al eje de rotaci√≥n, dicho eje se observa como un simple punto. Este lugar geom√©trico, conocido como el plano de rotaci√≥n, permite reducir un problema tridimensional a uno bidimensional, facilitando enormemente el c√°lculo de la posici√≥n de cualquier punto del robot. La relaci√≥n entre los sistemas de coordenadas se establece mediante matrices de transformaci√≥n homog√©nea (T), las cuales representan la traslaci√≥n y rotaci√≥n entre un sistema y el siguiente."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms x_O_1 y_O_1 theta_O_1 L_2 theta_1_2 L_3 theta_2_3 L_1\n",
    "\n",
    "%T_O_1 = Tij(x_O_1,y_O_1,0,0,0,theta_O_1)\n",
    "%T_1_2 = Tij(L_1,0,0,0,0,theta_1_2)\n",
    "%T_2_3 = Tij(L_2,0,0,0,0,theta_2_3)\n",
    "\n",
    "%T_3_P = Tij(L_3,0,0,0,0,0)\n",
    "\n",
    "%T_O_P = simplify(T_O_1*T_1_2*T_2_3*T_3_P)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Vector de postura del robot\n",
    "\n",
    "Se extrae la informaci√≥n m√°s relevante: la posici√≥n del punto P y el √°ngulo que define su orientaci√≥n. Se observa que ambos valores dependen de los datos obtenidos previamente, mostrando c√≥mo las uniones influyen en nuestro punto de inter√©s. Estos par√°metros conforman el vector de pose.\n",
    "\n",
    "En esencia, este proceso permite determinar la posici√≥n y orientaci√≥n del efector final en funci√≥n de un conjunto espec√≠fico de variables articulares"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%xi_O_P = [T_O_P(1,4);T_O_P(2,4);theta_O_1+theta_1_2+theta_2_3]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelo Cinem√°tico Inverso\n",
    "\n",
    "A diferencia del modelo directo, el modelo cinem√°tico inverso resuelve el problema opuesto: si conocemos la posici√≥n (y orientaci√≥n) deseada del efector final (x, y, œÜ), ¬øqu√© valores deben tomar los √°ngulos de las articulaciones (Œ∏‚ÇÅ, Œ∏‚ÇÇ, Œ∏‚ÇÉ) para alcanzar dicha posici√≥n?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%inv(J_theta); % Se comenta o elimina para evitar error de orden"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Este problema es fundamental en la rob√≥tica para la planificaci√≥n de trayectorias. Para un robot SCARA como el analizado, la soluci√≥n se puede encontrar a trav√©s de un m√©todo geom√©trico, analizando la vista superior del robot para resolver los √°ngulos necesarios mediante trigonometr√≠a.\n",
    "\n",
    "Para calcular el valor de los √°ngulos se utilizan las leyes de cosenos, de senos y el teorema de Pit√°goras. Se comienza con el c√°lculo de ay y ax, que son la suma de las proyecciones de los tri√°ngulos rect√°ngulos que se forman con theta_0_1 y theta_1_2. Usando matlab"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%a_y=L_1*sin(theta_O_1)+L_2*sin(theta_O_1+theta_1_2)\n",
    "%a_x = L_1*cos(theta_O_1)+L_2*cos(theta_O_1)+L_2*cos(theta_O_1+theta_1_2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Utilizando el teorema de Pit√°goras, es posible determinar la magnitud del vector R, que representa la distancia entre el sistema 1 y el sistema 2 del tri√°ngulo formado por las longitudes de los eslabones. Esta se calcula con la siguiente expresi√≥n:\n",
    "\n",
    "De la ley de cosenos podemos deducir el √°ngulo gamma:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%R = sqrt(a_x.^2 + a_y.^2)\n",
    "%gamma =acos ((R.^2 - L_1.^2)/(-2*L_1*L_2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para determinar el valor de Œ∏‚ÇÅ‚ÇÇ, se observa que el √°ngulo Œ≥ est√° estrechamente relacionado, ya que la suma de ambos √°ngulos es igual a œÄ. En consecuencia:\n",
    "\n",
    "Para determinar la expresi√≥n de Œ∏‚ÇÄ‚ÇÅ, es necesario calcular los √°ngulos Œ± y œà. El √°ngulo Œ± se obtiene a partir del tri√°ngulo rect√°ngulo formado por los sistemas de coordenadas 1 y 3, que pasa por el sistema 2. Para ello, se emplea la definici√≥n del coseno, aplic√°ndola primero en el tri√°ngulo menor y posteriormente en el tri√°ngulo mayor."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms L_1 L_2 theta_O_1 theta_1_2 alfa\n",
    "\n",
    "%numerador = L_1 + L_2*cos(theta_1_2);\n",
    "%denominador = sqrt( (L_1*cos(theta_O_1) + L_2*cos(theta_O_1 + theta_1_2))^2 + (L_1*sin(theta_O_1) + L_2*sin(theta_O_1 + theta_1_2))^2 );\n",
    "%cos_alfa = numerador / denominador\n",
    "%. Despejar alfa usando el arcocoseno (acos)\n",
    "%alfa = acos(cos_alfa)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para encontrar el √°ngulo ‚àÖ, se aplica el mismo procedimiento utilizando el tri√°ngulo formado por los vectores a_x y a_y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%Phi=atan2(a_y,a_x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Se emplea la funci√≥n atan2, ya que permite obtener soluciones en los cuatro cuadrantes del plano cartesiano. Por ello, resulta √∫til para garantizar que cualquier posici√≥n tenga una soluci√≥n v√°lida. A partir de la imagen de referencia, se observa que el √°ngulo œà corresponde a la suma de los √°ngulos Œ∏‚ÇÄ‚ÇÅ y Œ±. En consecuencia, se establece la siguiente relaci√≥n:\n",
    "\n",
    "De esta expresi√≥n se puede despejar ùúÉ_0_1 como:\n",
    "\n",
    "Para obtener la expresi√≥n de ùúÉ_2_3, se sigue un procedimiento similar.\n",
    "\n",
    "Se utiliza el teorema de Pit√°goras para determinar la longitud del segmento ùëÅ\n",
    "\n",
    "Posteriormente, se despeja el √°ngulo œá de la ley de los cosenos. Dado que los √°ngulos œá, Œ≤ y Œ∏2,3 forman un √°ngulo œÄ, se tiene la siguiente relaci√≥n:\n",
    "\n",
    "Para determinar el valor del √°ngulo ùúÖ, se emplea la definici√≥n de la tangente:\n",
    "\n",
    "Finalmente, considerando la relaci√≥n entre los √°ngulos, se tiene:\n",
    "\n",
    "Con esto se obtiene la definici√≥n completa de cada uno de los √°ngulos que determinan las articulaciones del robot, lo que permite alcanzar la configuraci√≥n deseada del punto P dentro del plano de trabajo."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelo cinem√°tico directo de las velocidades\n",
    "\n",
    "Para analizar las velocidades del robot, se utiliza la matriz Jacobiana (J). Esta matriz es una herramienta matem√°tica fundamental que relaciona las velocidades de las articulaciones (el vector de velocidades angulares de los motores) con las velocidades del efector final (la velocidad lineal y angular de la \"mano\" del robot).\n",
    "\n",
    "La relaci√≥n se describe con la ecuaci√≥n:\n",
    "\n",
    "Donde:\n",
    "- es el vector de velocidades del efector final.\n",
    "- es la matriz Jacobiana, que depende de la configuraci√≥n actual del robot (los √°ngulos q).\n",
    "-  es el vector de velocidades de las articulaciones.\n",
    "\n",
    "A continuaci√≥n se presenta el c√°lculo de la Jacobiana para este robot, as√≠ como de su inversa, la cual permite realizar el c√°lculo cinem√°tico inverso de las velocidades."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms J_theta\n",
    "\n",
    "%J_theta \n",
    "%J_theta = jacobian(xi_O_P,[theta_O_1, theta_1_2,theta_2_3])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelo cinem√°tico inverso de las velocidades\n",
    "\n",
    "Para obtener las velocidades articulares, se despeja el vector Œ∏Àôde la expresi√≥n de la cinem√°tica directa de velocidades. Multiplicamos por ambos lados de la igualdad la inversa del jacobiano lo cual permite aislar las velocidades articulares:\n",
    "\n",
    "Donde:\n",
    "‚Ä¢ Œ∏Àô es el vector de velocidades articulares.\n",
    "‚Ä¢ xÀô es el vector de velocidad lineal y angular de la pose.\n",
    "‚Ä¢ J‚àí1(Œ∏) es la inversa del Jacobiano.\n",
    "\n",
    "Normalmente, cuando el Jacobiano no es una matriz cuadrada ‚Äîes decir, cuando el n√∫mero de grados de libertad del robot no coincide con la dimensi√≥n del espacio de tareas se recurre al uso de la seudo-inversa para resolver la cinem√°tica inversa de velocidades. Sin embargo, en este caso particular, dado que el Jacobiano es una matriz cuadrada (3√ó3), es suficiente con calcular su inversa directa para obtener una soluci√≥n exacta, siempre que el sistema no se encuentre en una configuraci√≥n singular. Una configuraci√≥n singular se presenta en determinadas posiciones del robot en las que el efector final pierde uno o m√°s grados de libertad, limitando as√≠ su capacidad de movimiento o control en ciertas direcciones del espacio de trabajo."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%inv(J_theta)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Rango de movimiento.\n",
    "\n",
    "Otro aspecto importante a considerar es el determinante del Jacobiano, ya que este valor proporciona informaci√≥n relevante sobre el espacio de trabajo del robot SCARA. El determinante refleja la capacidad de movimiento del efector final: cuando su valor se aproxima a cero, el manipulador pierde uno o m√°s grados de libertad, impidiendo su desplazamiento libre en determinadas direcciones dentro del espacio de trabajo."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%d= det(J_theta)\n",
    "%determinante_J = simplify(d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para analizar este comportamiento, se estudian las variables que influyen directamente en el determinante del Jacobiano. Para la elaboraci√≥n de la gr√°fica, se fijan las longitudes de los eslabones y se var√≠a el √°ngulo del que depende el determinante, con el objetivo de observar c√≥mo esta variaci√≥n afecta la capacidad de movimiento del manipulador. A continuaci√≥n, se presenta el c√≥digo empleado para realizar dicho an√°lisis:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms theta_1_2 L1 L2\n",
    "detJ= L1 * L2 * sin(theta_1_2);\n",
    "f_detJ= matlabFunction(detJ, 'Vars', [theta_1_2, L1, L2]);\n",
    "\n",
    "%Rango de valores\n",
    "theta_1_2_vals = linspace(-pi, pi , 500);\n",
    "L1_val = 1;\n",
    "L2_val =1;\n",
    "\n",
    "%Evaluar determinante\n",
    "det_vals = f_detJ(theta_1_2_vals, L1_val, L2_val);\n",
    "\n",
    "%Grafica\n",
    "figure  \n",
    "plot(theta_1_2_vals, det_vals,'LineWidth',2)\n",
    "xlabel('\\theta_{1,2} (rad)')\n",
    "ylabel('Determinante del Jacobiano')\n",
    "title('Determinante del Jacobiano vs \\theta {1,2}')\n",
    "grid on\n",
    "yline(0, '--r', 'Singularidad')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Se observa que, cuando el √°ngulo Œ∏‚ÇÅ‚ÇÇ es igual a cero, el determinante del Jacobiano tambi√©n toma el valor de cero. A medida que el √°ngulo incrementa hasta œÄ/2 (‚âà 1.5708 rad), el determinante alcanza su valor m√°ximo. El valor del determinante est√° directamente influenciado por las longitudes de los eslabones: cuanto mayores sean dichas longitudes, m√°s amplio ser√° el rango de movimiento del sistema. En el an√°lisis realizado, se consideraron longitudes unitarias con el fin de simplificar el modelo y facilitar la interpretaci√≥n de los resultados."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelo cinem√°tico de las aceleraciones\n",
    "\n",
    "El modelo cinem√°tico de las aceleraciones se obtiene al derivar con respecto al tiempo el modelo de velocidades. Este an√°lisis es crucial para el control din√°mico del robot, ya que las aceleraciones est√°n directamente relacionadas con las fuerzas y torques que los motores deben generar. La ecuaci√≥n que relaciona la aceleraci√≥n del efector final () con las aceleraciones de las articulaciones () es:\n",
    "\n",
    "Donde  representa la derivada de la matriz Jacobiana con respecto al tiempo. A continuaci√≥n, se proceder√° a calcular esta derivada y a construir el modelo completo."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "% --- C√ìDIGO DEFINITIVO PARA J_dot (Regla de la Cadena) ---\n",
    "\n",
    "% 1. Definimos las velocidades de las articulaciones como nuevas variables simb√≥licas\n",
    "% syms theta_dot_O_1 theta_dot_1_2 theta_dot_2_3 % (Ya definidas)\n",
    "\n",
    "% 2. Creamos un vector de variables de articulaci√≥n (q) y un vector de velocidades (q_dot)\n",
    "% OJO: q_dot DEBE ser un vector columna (con punto y coma) para que funcione la multiplicaci√≥n\n",
    "% q = [theta_O_1, theta_1_2, theta_2_3];\n",
    "% q_dot = [theta_dot_O_1; theta_dot_1_2; theta_dot_2_3];\n",
    "\n",
    "% 3. Calculamos la derivada del Jacobiano (J_dot) usando la regla de la cadena\n",
    "% J_dot = sym(zeros(size(J_theta)));\n",
    "% for i = 1:length(q)\n",
    "%     J_dot = J_dot + diff(J_theta, q(i)) * q_dot(i);\n",
    "% end\n",
    "\n",
    "% Mostramos el resultado final de J_dot\n",
    "% J_dot;"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Una vez obtenida la derivada del Jacobiano, se procede a derivar tambi√©n el vector de velocidades articulares para completar el modelo cinem√°tico de las aceleraciones."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms theta_ddot_O_1 theta_ddot_1_2 theta_ddot_2_3\n",
    "%q_ddot = [theta_ddot_O_1; theta_ddot_1_2; theta_ddot_2_3];\n",
    "%q_ddot"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "De este modo, se construye la expresi√≥n total de la aceleraci√≥n del efector final.\n",
    "\n",
    "Donde:  es igual a:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms theta_acel_O_1 theta_acel_1_2 theta_acel_2_3 \n",
    "%syms theta_acel1_O_1 theta_acel1_1_2 theta_acel1_2_3\n",
    "%dq = [theta_acel_O_1; theta_acel_1_2; theta_acel_2_3];\n",
    "%ddq = [theta_acel1_O_1; theta_acel1_1_2; theta_acel1_2_3];\n",
    "\n",
    "%dJ = sym(zeros(size(J_theta)));\n",
    "%theta_vec = [theta_O_1; theta_1_2; theta_2_3];\n",
    "%for i = 1:length(theta_vec)\n",
    "%    dJ = dJ + diff(J_theta, theta_vec(i)) * dq(i);\n",
    "%end\n",
    "\n",
    "% Modelo cinem√°tico directo de aceleraciones\n",
    "%ddx = simplify(dJ * dq + J_theta * ddq);\n",
    "%disp(ddx)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Adicionalmente, el control de la aceleraci√≥n es indispensable para la planificaci√≥n de trayectorias suaves y precisas. Al gestionar c√≥mo cambia la velocidad, se evitan movimientos bruscos o \"tirones\" (jerk), lo cual es cr√≠tico para la integridad mec√°nica del manipulador y para la correcta ejecuci√≥n de tareas delicadas como soldadura o ensamblaje."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelo Cinem√°tico Inverso de Aceleraciones\n",
    "\n",
    "El modelo inverso se obtiene al despejar la aceleraci√≥n de las articulaciones () de la ecuaci√≥n del modelo directo. Este c√°lculo es esencial para los algoritmos de control que siguen trayectorias precisas.\n",
    "\n",
    "La ecuaci√≥n resultante es:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms ddx1 ddx2 ddx3 real\n",
    "%ddx_vec = [ddx1; ddx2; ddx3];\n",
    "\n",
    "%ddq_inv= simplify(pinv(J_theta) * (ddx_vec - dJ * dq));\n",
    "%disp(ddq_inv)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Todos los componentes de esta ecuaci√≥n ya han sido calculados simb√≥licamente en el script: la inversa del Jacobiano () se obtuvo en la secci√≥n de velocidades, y la derivada del Jacobiano () se acaba de calcular."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "% --- C√≥digo Ilustrativo para el Modelo Cinem√°tico Inverso de Aceleraciones ---\n",
    "\n",
    "% 1. Definimos la entrada del problema: la aceleraci√≥n deseada del efector final.\n",
    "% Como es una ilustraci√≥n, lo creamos como un vector simb√≥lico gen√©rico.\n",
    "%syms x_ddot_deseado y_ddot_deseado theta_ddot_deseado\n",
    "%x_ddot_in = [x_ddot_deseado; y_ddot_deseado; theta_ddot_deseado];\n",
    "\n",
    "% 2. Calculamos la inversa del Jacobiano (J_inv).\n",
    "%J_inv = inv(J_theta);\n",
    "\n",
    "% 3. Implementamos la f√≥rmula de la cinem√°tica inversa de aceleraciones:\n",
    "% q_ddot = J_inv * (x_ddot_in - J_dot * q_dot)\n",
    "%q_ddot_calculado = J_inv * (x_ddot_in - J_dot * q_dot);\n",
    "\n",
    "% 4. Mostramos el resultado simb√≥lico (ser√° una expresi√≥n muy grande).\n",
    "% Le pedimos a MATLAB que lo simplifique para que sea m√°s legible.\n",
    "%q_ddot_calculado = simplify(q_ddot_calculado)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Modelo din√°mico por ecuaciones de E√ºler-Lagrange\n",
    "\n",
    "El modelo din√°mico describe la relaci√≥n entre las fuerzas/torques aplicados por los motores y el movimiento resultante del robot, considerando factores como masas e inercias. En este reporte, se utiliza la formulaci√≥n de Euler-Lagrange, un m√©todo basado en la energ√≠a del sistema.\n",
    "\n",
    "Se calculan la energ√≠a cin√©tica (K, por el movimiento) y la energ√≠a potencial (U, por la gravedad) de cada eslab√≥n. El Lagrangiano (L = K - U) se utiliza para derivar las ecuaciones de movimiento que definen el torque (œÑ) requerido en cada articulaci√≥n para producir un movimiento deseado. Se emplearan las siguientes ecuaciones para el c√°lculo de la energ√≠a cin√©tica:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms x_1_C1 theta_dot_O_1\n",
    "\n",
    "v_C1_C1 = [0;x_1_C1*theta_dot_O_1;0]\n",
    "v_O_C1 = [-x_1_C1*sin(theta_O_1)*theta_dot_O_1;x_1_C1*cos(theta_O_1)*theta_dot_O_1;0]\n",
    "transpose(v_C1_C1)*v_C1_C1\n",
    "simplify(transpose(v_O_C1)*v_O_C1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para calcular el primer t√©rmino de la energ√≠a cin√©tica, correspondiente a la velocidad lineal de los centros de masa de cada eslab√≥n, existen dos m√©todos v√°lidos. El primero consiste en realizar una propagaci√≥n de velocidades desde el eslab√≥n base hasta cada eslab√≥n sucesivo. El segundo m√©todo consiste en calcular la posici√≥n del centro de gravedad de cada eslab√≥n respecto al sistema inercial de coordenadas, y posteriormente derivar dicha posici√≥n para obtener la velocidad lineal."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Propagaci√≥n de velocidades\n",
    "\n",
    "Para aplicar el primer m√©todo mediante propagaci√≥n de velocidades, se emplean las siguientes f√≥rmulas: \n",
    "velocidades angulares:\n",
    "velocidades lineales:\n",
    "\n",
    "Se sacan la matriz de orientaci√≥n de cada uno de los sistemas colocados en las juntas y se transpone. Estos datos se obtienen de la matriz de trasformaciones de cada junta con respecto al punto inmediato anterior (T_O_1, T_1_2, T_2_3)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%Para R_O_1\n",
    "%R_0_1 = [T_O_1(1,1),T_O_1(1,2),T_O_1(1,3);T_O_1(2,1),T_O_1(2,2),T_O_1(2,3);T_O_1(3,1),T_O_1(3,2),T_O_1(3,3)]\n",
    "%R_1_0 = transpose(R_0_1)\n",
    "\n",
    "%Para R_1_2\n",
    "%R_1_2 = [T_1_2(1,1),T_1_2(1,2),T_1_2(1,3);T_1_2(2,1),T_1_2(2,2),T_1_2(2,3);T_1_2(3,1),T_1_2(3,2),T_1_2(3,3)]\n",
    "%R_2_1 = transpose(R_1_2)\n",
    "\n",
    "%Para R_2_3\n",
    "%R_2_3 = [T_2_3(1,1),T_2_3(1,2),T_2_3(1,3);T_2_3(2,1),T_2_3(2,2),T_2_3(2,3);T_2_3(3,1),T_2_3(3,2),T_2_3(3,3)]\n",
    "%R_3_2 = transpose(R_2_3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para obtener las velocidades lineales de los centros de masa, es necesario calcular previamente las velocidades angulares de cada eslab√≥n. Esto se logra definiendo un vector unitario que indique la direcci√≥n del eje de rotaci√≥n. En este caso, dado que el movimiento ocurre alrededor del eje Z, se tiene:\n",
    "\n",
    "Se utiliza la transpuesta de la matriz de orientaci√≥n que anteriormente se calcul√≥, la derivada angular correspondiente a cada eslab√≥n y la velocidad angular anterior."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms omega_1_1 omega_2_2 omega_3_3\n",
    "\n",
    "%Para omega_0_0\n",
    "omega_O_O=[0;0;0]\n",
    "n_1_1 = [0;0;1]\n",
    "\n",
    "%R_O_1 = [T_O_1(1,1),T_O_1(1,2),T_O_1(1,3);T_O_1(2,1),T_O_1(2,2),T_O_1(2,3);T_O_1(3,1),T_O_1(3,2),T_O_1(3,3)]\n",
    "%R_1_O = transpose(R_O_1)\n",
    "\n",
    "%omega_1_1:\n",
    "%Ecuaci√≥n de propagaci√≥n\n",
    "%omega_1_1 = R_1_O*omega_O_O+n_1_1*theta_dot_O_1\n",
    "\n",
    "%omega_2_2:\n",
    "%Propagaci√≥n para el segundo cuerpo\n",
    "n_2_2 = [0;0;1]\n",
    "%R_1_2 = [T_1_2(1,1),T_1_2(1,2),T_1_2(1,3);T_1_2(2,1),T_1_2(2,2),T_1_2(2,3);T_1_2(3,1),T_1_2(3,2),T_1_2(3,3)]\n",
    "%R_2_1 = transpose(R_1_2)\n",
    "\n",
    "%Ecuaci√≥n de propagaci√≥n\n",
    "%omega_2_2 = R_2_1*omega_1_1+n_2_2*theta_dot_1_2\n",
    "\n",
    "%omega_3_3:\n",
    "%Propagaci√≥n para el tercer cuerpo\n",
    "n_3_3 = [0;0;1]\n",
    "%R_2_3 = [T_2_3(1,1),T_2_3(1,2),T_2_3(1,3);T_2_3(2,1),T_2_3(2,2),T_2_3(2,3);T_2_3(3,1),T_2_3(3,2),T_2_3(3,3)]\n",
    "%R_3_2 = transpose(R_2_3)\n",
    "\n",
    "%Ecuaci√≥n de propagaci√≥n\n",
    "%omega_3_3=R_3_2*omega_2_2+n_3_3*theta_dot_2_3\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para la primera parte, la velocidad lineal del sistema uno utilizando la formula est√° dada por:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "% --- C√°lculo de la Velocidad Lineal v_1_1 ---\n",
    "\n",
    "% La velocidad lineal de la base del robot (v_O_O) es cero.\n",
    "v_O_O = [0;0;0];\n",
    "\n",
    "% La velocidad angular de la base (omega_O_O) es cero.\n",
    "% (Aseg√∫rate de que esta l√≠nea est√© con punto y coma en tu c√≥digo).\n",
    "omega_O_O = [0;0;0];\n",
    "\n",
    "% El vector de posici√≥n desde el origen {O} al origen {1} es cero,\n",
    "% ya que est√°n en el mismo lugar.\n",
    "p_O_1 = [0;0;0];\n",
    "\n",
    "% Aplicamos la ecuaci√≥n de propagaci√≥n de la velocidad lineal:\n",
    "% v_1_1 = R_1_O * (v_O_O + cross(omega_O_O, p_O_1))\n",
    "%v_1_1 = R_1_O * (v_O_O + cross(omega_O_O, p_O_1))\n",
    "\n",
    "%Para el sistema 2 se tiene:\n",
    "%v_2_2 = R_2_1*(v_1_1 + cross(omega_1_1,[L1;0;0]))\n",
    "\n",
    "%Para el sistema 3:\n",
    "%V_3_3 = simplify(R_3_2*(v_2_2+cross(omega_2_2,[L2;0;0])))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para calcular la propagaci√≥n de velocidades hacia los centros de masa, se emplea la misma formulaci√≥n utilizada en la propagaci√≥n entre juntas, considerando adicionalmente que las velocidades angulares en el centro de masa de cada eslab√≥n son iguales a las del sistema de coordenadas asociado a la junta correspondiente. A continuaci√≥n, se analiza el c√°lculo para el centro de masa del primer eslab√≥n:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "v_C1_C1 = [0;x_1_C1*theta_dot_O_1;0]\n",
    "\n",
    "%Para el centro de masa del segundo:\n",
    "%v_C2_C2 = ([1, 0, 0; 0, 1, 0; 0, 0, 1]*(v_2_2 + cross(omega_2_2,[x_2_C2; 0; 0])))\n",
    "\n",
    "%Para el centro de masa del tercer eslab√≥n:\n",
    "%v_c3_c3 = ([1,0,0;0,1,0;0,0,1]*(V_3_3+cross(omega_3_3,[x_3_C3;0;0])))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para estas velocidades, la matriz de orientaci√≥n es la matriz identidad debido a que el sistema de la junta no cambia con respecto al del centro de masa."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### C√°lculo de la posici√≥n de los centros de masa\n",
    "\n",
    "Para hacerlo con el c√°lculo de la posici√≥n del centro de gravedad, se obtiene primero las trasformadas de cada punto de inter√©s, suponiendo que el centro de masa de cada eslab√≥n se encuentra justo en su punto medio. Se considera que el sistema de referencia asociado al centro de gravedad est√° orientado de manera id√©ntica al sistema de coordenadas del eslab√≥n correspondiente."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms x_1_C1 x_2_C2 x_3_C3\n",
    "\n",
    "%La transformada de C1\n",
    "%T_1_C1 = Tij(x_1_C1,0,0,0,0,0)\n",
    "%T_O_C1 = T_O_1*T_1_C1\n",
    "\n",
    "%La transformada de C2\n",
    "%T_2_C2 = Tij(x_2_C2,0,0,0,0,0)\n",
    "%T_O_C2 = T_O_1*T_1_2*T_2_C2\n",
    "\n",
    "%La transformada de C3\n",
    "%T_3_C3 = Tij(x_3_C3,0,0,0,0,0)\n",
    "%T_O_C3 = T_O_1*T_1_2*T_2_3*T_3_C3\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Se sacan los datos de la posici√≥n de cada trasformaci√≥n."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%Para P_O_C1\n",
    "%Vectores de posici√≥n\n",
    "%p_O_C1 = [T_O_C1(1,4);T_O_C1(2,4);T_O_C1(3,4)]\n",
    "\n",
    "%Para P_O_C2\n",
    "%p_O_C2 = simplify([T_O_C2(1,4);T_O_C2(2,4);T_O_C2(3,4)])\n",
    "\n",
    "%Para P_O_C3\n",
    "%p_O_C3 = simplify([T_O_C3(1,4);T_O_C3(2,4);T_O_C3(3,4)])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### C√°lculo de las velocidades"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms theta_dot_O_1 theta_dot_1_2 theta_dot_2_3\n",
    "\n",
    "%Para V_O_C1\n",
    "%v_O_C1 = diff(p_O_C1,theta_O_1)*theta_dot_O_1+diff(p_O_C1,theta_1_2)*theta_dot_1_2+diff(p_O_C1,theta_2_3)*theta_dot_2_3\n",
    "\n",
    "%Para V_O_C2\n",
    "%v_O_C2 = diff(p_O_C2,theta_O_1)*theta_dot_O_1+diff(p_O_C2,theta_1_2)*theta_dot_1_2+diff(p_O_C2,theta_2_3)*theta_dot_2_3\n",
    "\n",
    "%Para V_O_C3\n",
    "%v_O_C3 = diff(p_O_C3,theta_O_1)*theta_dot_O_1+diff(p_O_C3,theta_1_2)*theta_dot_1_2+diff(p_O_C3,theta_2_3)*theta_dot_2_3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### C√°lculo de la velocidades angulares"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms omega_1_1 omega_2_2 omega_3_3\n",
    "\n",
    "%Propagaci√≥n para el primer cuerpo\n",
    "omega_O_O = [0;0;0]\n",
    "n_1_1 = [0;0;1]\n",
    "%R_O_1 = [T_O_1(1,1),T_O_1(1,2),T_O_1(1,3);T_O_1(2,1),T_O_1(2,2),T_O_1(2,3);T_O_1(3,1),T_O_1(3,2),T_O_1(3,3)]\n",
    "%R_1_O = transpose(R_O_1)\n",
    "\n",
    "%Ecuaci√≥n de propagaci√≥n\n",
    "%omega_1_1 = R_1_O*omega_O_O+n_1_1*theta_dot_O_1\n",
    "\n",
    "%Propagaci√≥n para el segundo cuerpo\n",
    "n_2_2 = [0;0;1]\n",
    "%R_1_2 = [T_1_2(1,1),T_1_2(1,2),T_1_2(1,3);T_1_2(2,1),T_1_2(2,2),T_1_2(2,3);T_1_2(3,1),T_1_2(3,2),T_1_2(3,3)]\n",
    "%R_2_1 = transpose(R_1_2)\n",
    "\n",
    "%Ecuaci√≥n de propagaci√≥n\n",
    "%omega_2_2 = R_2_1*omega_1_1+n_2_2*theta_dot_1_2\n",
    "\n",
    "%Propagaci√≥n para el tercer cuerpo\n",
    "n_3_3 = [0;0;1]\n",
    "%R_2_3 = [T_2_3(1,1),T_2_3(1,2),T_2_3(1,3);T_2_3(2,1),T_2_3(2,2),T_2_3(2,3);T_2_3(3,1),T_2_3(3,2),T_2_3(3,3)]\n",
    "%R_3_2 = transpose(R_2_3)\n",
    "\n",
    "%Ecuaci√≥n de propagaci√≥n\n",
    "%omega_3_3 = R_3_2*omega_2_2+n_3_3*theta_dot_2_3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Defici√≥n de los elementos de inercia"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "syms g I_xx1 I_yy1 I_zz1 I_xx2 I_yy2 I_zz2 I_xx3 I_yy3 I_zz3\n",
    "%vector de gravedad\n",
    "g_v = [0;-g;0]\n",
    "\n",
    "I_C1 = [I_xx1,0,0;0,I_yy1,0;0,0,I_zz1]\n",
    "I_C2 = [I_xx2,0,0;0,I_yy2,0;0,0,I_zz2]\n",
    "I_C3 = [I_xx3,0,0;0,I_yy3,0;0,0,I_zz3]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## C√°culo del Lagrangeano"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms m_1 m_2 m_3\n",
    "%energ√≠a cin√©tica de cada uno de los cuerpos\n",
    "\n",
    "%k_1 = simplify((m_1/2)*transpose(v_O_C1)*v_O_C1+(1/2)*transpose(omega_1_1)*I_C1*omega_1_1)\n",
    "\n",
    "%k_2 = simplify((m_2/2)*transpose(v_O_C2)*v_O_C2+(1/2)*transpose(omega_2_2)*I_C2*omega_2_2)\n",
    "\n",
    "%k_3 = simplify((m_3/2)*transpose(v_O_C3)*v_O_C3+(1/2)*transpose(omega_3_3)*I_C3*omega_3_3)\n",
    "\n",
    "% C√°clulo de la energ√≠a potencial de cada cuerpo\n",
    "%u_1 = -m_1*transpose(p_O_C1)*g_v\n",
    "%u_2 = -m_2*transpose(p_O_C2)*g_v\n",
    "%u_3 = -m_3*transpose(p_O_C3)*g_v"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### C√°lculo del Lagrangeano"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%La = (k_1+k_2+k_3)-(u_1+u_2+u_3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## C√°lculo de los pares"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%syms theta_ddot_O_1 theta_ddot_1_2 theta_ddot_2_3\n",
    "\n",
    "%D_theta1 = diff(La,theta_dot_O_1);\n",
    "\n",
    "% C√°lculo de relaci√≥n\n",
    "%tao_1 = diff(D_theta1,theta_O_1)*theta_dot_O_1 + diff(D_theta1,theta_1_2)*theta_dot_1_2 + diff(D_theta1,theta_2_3)*theta_dot_2_3 + diff(D_theta1,theta_dot_O_1)*theta_ddot_O_1+ diff(D_theta1,theta_dot_1_2)*theta_ddot_1_2+ diff(D_theta1,theta_dot_2_3)*theta_ddot_2_3-diff(La,theta_O_1);\n",
    "\n",
    "%D_theta2 = diff(La,theta_dot_1_2);\n",
    "%tao_2 = diff(D_theta2,theta_O_1)*theta_dot_O_1 + diff(D_theta2,theta_1_2)*theta_dot_1_2 + diff(D_theta2,theta_2_3)*theta_dot_2_3 + diff(D_theta2,theta_dot_O_1)*theta_ddot_O_1+ diff(D_theta2,theta_dot_1_2)*theta_ddot_1_2+ diff(D_theta2,theta_dot_2_3)*theta_ddot_2_3-diff(La,theta_1_2);\n",
    "\n",
    "%D_theta3 = diff(La,theta_dot_2_3);\n",
    "%tao_3 = diff(D_theta3,theta_O_1)*theta_dot_O_1 + diff(D_theta3,theta_1_2)*theta_dot_1_2 + diff(D_theta3,theta_2_3)*theta_dot_2_3 + diff(D_theta3,theta_dot_O_1)*theta_ddot_O_1+ diff(D_theta3,theta_dot_1_2)*theta_ddot_1_2+ diff(D_theta3,theta_dot_2_3)*theta_ddot_2_3-diff(La,theta_2_3);\n",
    "\n",
    "%tao = [tao_1;tao_2;tao_3];"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "% C√°lculo de la matriz de inercia\n",
    "\n",
    "%M1 = subs(tao,[theta_ddot_O_1,theta_ddot_1_2,theta_ddot_2_3,theta_dot_O_1,theta_dot_1_2,theta_dot_2_3,g],[1,0,0,0,0,0,0]);\n",
    "%M2 = subs(tao,[theta_ddot_O_1,theta_ddot_1_2,theta_ddot_2_3,theta_dot_O_1,theta_dot_1_2,theta_dot_2_3,g],[0,1,0,0,0,0,0]);\n",
    "%M3 = subs(tao,[theta_ddot_O_1,theta_ddot_1_2,theta_ddot_2_3,theta_dot_O_1,theta_dot_1_2,theta_dot_2_3,g],[0,0,1,0,0,0,0]);\n",
    "\n",
    "%M_theta = collect([M1 M2 M3],[m_1,m_2,m_3]);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### C√°lculo del vector de pares de"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%V_theta = subs(tao,[theta_ddot_O_1,theta_ddot_1_2,theta_ddot_2_3,theta_dot_O_1,theta_dot_1_2,theta_dot_2_3,g],[0,0,0,theta_dot_O_1,theta_dot_1_2,theta_dot_2_3,0]);\n",
    "%G_theta = subs(tao,[theta_ddot_O_1,theta_ddot_1_2,theta_ddot_2_3,theta_dot_O_1,theta_dot_1_2,theta_dot_2_3,g],[0,0,0,0,0,0,g]);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### C√°lculo del modelo Din√°mico directo\n",
    "\n",
    "Para el c√°lculo del modelo din√°mico se obtiene tau de manera simb√≥lica con la matriz de inercia (M_theta) y el vector de pares (V_theta y G_theta)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%tau = M_theta * [theta_ddot_O_1; theta_ddot_1_2; theta_ddot_2_3] + V_theta + G_theta;\n",
    "%disp(tau)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Calculo del modelo dinamico inverso"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%Invtheta_ddot = inv(M_theta) * (tau - V_theta - G_theta);\n",
    "%disp(Invtheta_ddot)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conclusiones\n",
    "\n",
    "Al finalizar este reporte, se ha cumplido con el objetivo principal de desarrollar y documentar de manera integral el modelo matem√°tico de un robot SCARA de tres grados de libertad. Este proceso no solo consisti√≥ en la aplicaci√≥n de f√≥rmulas, sino en la construcci√≥n de un verdadero \"gemelo digital\" que nos permite comprender y predecir el comportamiento del robot. A trav√©s de este desarrollo, se ha podido constatar que la cinem√°tica y la din√°mica son dos caras de la misma moneda. Mientras que la cinem√°tica nos proporciona el \"mapa\" del movimiento del robot, permiti√©ndonos saber d√≥nde est√° y c√≥mo llegar a un punto, la din√°mica nos da la \"fuerza\" para seguir ese mapa, conectando el movimiento abstracto con la realidad f√≠sica de los motores, las inercias y la gravedad. Un aprendizaje clave fue entender c√≥mo el Jacobiano y su derivada son el puente fundamental entre la postura y el movimiento a alta velocidad. El desarrollo del modelo din√°mico mediante la formulaci√≥n de Euler-Lagrange result√≥ ser la etapa m√°s compleja, generando ecuaciones de gran extensi√≥n. Esto resalta la importancia y la potencia de las herramientas de c√°lculo simb√≥lico como MATLAB, sin las cuales el manejo de dicha complejidad ser√≠a una tarea pr√°cticamente irrealizable a mano.\n",
    "\n",
    "Con este modelo completo, el siguiente paso l√≥gico y fundamental es la simulaci√≥n. La validaci√≥n de estos modelos en un entorno virtual permitir√° probar trayectorias y estrategias de control de forma segura y eficiente, antes de su implementaci√≥n en un manipulador f√≠sico, cerrando as√≠ el ciclo de dise√±o y an√°lisis en la rob√≥tica."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "MATLAB",
   "language": "matlab",
   "name": "matlab"
  },
  "language_info": {
   "file_extension": ".m",
   "mimetype": "text/x-matlab",
   "name": "matlab"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
